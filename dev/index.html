<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · Whitening.jl</title><meta name="title" content="Home · Whitening.jl"/><meta property="og:title" content="Home · Whitening.jl"/><meta property="twitter:title" content="Home · Whitening.jl"/><meta name="description" content="Documentation for Whitening.jl."/><meta property="og:description" content="Documentation for Whitening.jl."/><meta property="twitter:description" content="Documentation for Whitening.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>Whitening.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Types"><span>Types</span></a></li><li><a class="tocitem" href="#Functions"><span>Functions</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/andrewjradcliffe/Whitening.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/andrewjradcliffe/Whitening.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Whitening.jl-Documentation"><a class="docs-heading-anchor" href="#Whitening.jl-Documentation">Whitening.jl Documentation</a><a id="Whitening.jl-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Whitening.jl-Documentation" title="Permalink"></a></h1><ul><li><a href="#Whitening.jl-Documentation">Whitening.jl Documentation</a></li><li class="no-marker"><ul><li><a href="#Types">Types</a></li><li><a href="#Functions">Functions</a></li><li><a href="#Index">Index</a></li></ul></li></ul><h2 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Whitening.AbstractWhiteningTransform" href="#Whitening.AbstractWhiteningTransform"><code>Whitening.AbstractWhiteningTransform</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type which represents a <a href="https://en.wikipedia.org/wiki/Whitening_transformation">whitening transformation</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andrewjradcliffe/Whitening.jl/blob/0c16dafc2f51795aa89583673a9b0aceb17f76f0/src/abstract.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Whitening.Chol" href="#Whitening.Chol"><code>Whitening.Chol</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Chol{T&lt;:Base.IEEEFloat} &lt;: AbstractWhiteningTransform{T}</code></pre><p>Cholesky whitening transform.</p><p>Given the Cholesky decomposition of the inverse covariance matrix, <span>$Σ⁻¹ = LLᵀ$</span>, we have the whitening matrix, <span>$W = Lᵀ$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andrewjradcliffe/Whitening.jl/blob/0c16dafc2f51795aa89583673a9b0aceb17f76f0/src/Chol.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Whitening.Chol-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Union{Float16, Float32, Float64}" href="#Whitening.Chol-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Union{Float16, Float32, Float64}"><code>Whitening.Chol</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Chol(X::AbstractMatrix{T}) where {T&lt;:Base.IEEEFloat}</code></pre><p>Construct a Cholesky transformer from the from the <code>q × n</code> matrix, each row of which is a sample of an <code>n</code>-dimensional random variable.</p><p>In order for the resultant covariance matrix to be positive definite, <code>q</code> must be ≥ <code>n</code> and none of the variances may be zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andrewjradcliffe/Whitening.jl/blob/0c16dafc2f51795aa89583673a9b0aceb17f76f0/src/Chol.jl#L35-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Whitening.Chol-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractMatrix{T}}} where T&lt;:Union{Float16, Float32, Float64}" href="#Whitening.Chol-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractMatrix{T}}} where T&lt;:Union{Float16, Float32, Float64}"><code>Whitening.Chol</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Chol(μ::AbstractVector{T}, Σ::AbstractMatrix{T}) where {T&lt;:Base.IEEEFloat}</code></pre><p>Construct a Cholesky transformer from the from the mean vector, <code>μ</code> ∈ ℝⁿ, and a covariance matrix, <code>Σ</code> ∈ ℝⁿˣⁿ; <code>Σ</code> must be symmetric and positive definite.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andrewjradcliffe/Whitening.jl/blob/0c16dafc2f51795aa89583673a9b0aceb17f76f0/src/Chol.jl#L25-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Whitening.GeneralizedPCA" href="#Whitening.GeneralizedPCA"><code>Whitening.GeneralizedPCA</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GeneralizedPCA{T&lt;:Base.IEEEFloat} &lt;: AbstractWhiteningTransform{T}</code></pre><p>Principal component analysis (PCA) whitening transform, generalized to support compression based on either</p><ol><li>a pre-determined number of components,</li><li>a fraction of the total squared cross-covariance, or</li><li>a relative tolerance on the number of eigenvalues greater than <code>rtol*λ₁</code> where <code>λ₁</code> is the largest eigenvalue of the covariance matrix.</li></ol><p>Given the eigendecomposition of the <span>$n × n$</span> covariance matrix, <span>$Σ = UΛUᵀ$</span>, with eigenvalues sorted in descending order, i.e. <span>$λ₁ ≥ λ₂ ⋯ ≥ λₙ$</span>, the first <span>$m$</span> components are selected according to one or more of the criteria listed above.</p><p>If <span>$m = n$</span>, then we have the canonical PCA whitening matrix,  <span>$W = Λ^{-\frac{1}{2}}Uᵀ$</span>. Otherwise, for <span>$m &lt; n$</span>, a map from <span>$ℝⁿ ↦ ℝᵐ$</span> is formed by removing the <span>$n - m$</span> rows from <span>$W$</span>, i.e. the components with the <span>$n - m$</span> smallest eigenvalues are removed. This is equivalent to selecting the <span>$m × m$</span> matrix from the upper left of <span>$Λ$</span> and the <span>$m × n$</span> matrix from the top of <span>$Uᵀ$</span>. The inverse transform is then formed by selecting the <span>$n × m$</span> matrix from the left of <span>$U$</span> and the same matrix from <span>$Λ$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andrewjradcliffe/Whitening.jl/blob/0c16dafc2f51795aa89583673a9b0aceb17f76f0/src/GeneralizedPCA.jl#L1-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Whitening.GeneralizedPCA-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Union{Float16, Float32, Float64}" href="#Whitening.GeneralizedPCA-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Union{Float16, Float32, Float64}"><code>Whitening.GeneralizedPCA</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">GeneralizedPCA(X::AbstractMatrix{T};
               num_components::Union{Int, Nothing}=nothing,
               vmin::Union{T, Nothing}=nothing,
               rtol::Union{T, Nothing}=nothing) where {T&lt;:Base.IEEEFloat}</code></pre><p>Construct a generalized PCA transformer from the <code>q × n</code> matrix, each row of which is a sample of an <code>n</code>-dimensional random variable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andrewjradcliffe/Whitening.jl/blob/0c16dafc2f51795aa89583673a9b0aceb17f76f0/src/GeneralizedPCA.jl#L93-L101">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Whitening.GeneralizedPCA-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractMatrix{T}}} where T&lt;:Union{Float16, Float32, Float64}" href="#Whitening.GeneralizedPCA-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractMatrix{T}}} where T&lt;:Union{Float16, Float32, Float64}"><code>Whitening.GeneralizedPCA</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">GeneralizedPCA(μ::AbstractVector{T}, Σ::AbstractMatrix{T};
               num_components::Union{Int, Nothing}=nothing,
               vmin::Union{T, Nothing}=nothing,
               rtol::Union{T, Nothing}=nothing) where {T&lt;:Base.IEEEFloat}</code></pre><p>Construct a generalized PCA transformer from the mean vector, <code>μ</code> ∈ ℝⁿ, and a covariance matrix, <code>Σ</code> ∈ ℝⁿˣⁿ; <code>Σ</code> must be symmetric and positive semi-definite.</p><p>The output dimension, <code>m</code>, of the transformer is determined from the optional arguments, where</p><ol><li>0 ≤ <code>num_components</code> ≤ n is a pre-determined size</li><li>0 ≤ <code>vmin</code> ≤ 1 is the fraction of the total squared cross-covariance,  hence, <code>m</code> is the smallest value such that <code>sum(λ[1:m]) ≥ vmin*sum(λ)</code>,  where <span>$λᵢ, i=1,…,n$</span> are the eigenvalues of <code>Σ</code> in descending order.</li><li><code>rtol</code> is the relative tolerance on the number of eigenvalues greater than <code>rtol*λ₁</code> where <code>λ₁</code> is the largest eigenvalue of <code>Σ</code>.</li></ol><p>If none of the 3 options are provided, the default is <code>rtol = n*eps(T)</code>. If 2 or more options are provided, the minimum of the resultant sizes will be chosen.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andrewjradcliffe/Whitening.jl/blob/0c16dafc2f51795aa89583673a9b0aceb17f76f0/src/GeneralizedPCA.jl#L54-L76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Whitening.GeneralizedPCAcor" href="#Whitening.GeneralizedPCAcor"><code>Whitening.GeneralizedPCAcor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GeneralizedPCAcor{T&lt;:Base.IEEEFloat} &lt;: AbstractWhiteningTransform{T}</code></pre><p>Scale-invariant principal component analysis (PCAcor) whitening transform, generalized to support compression based on either</p><ol><li>a pre-determined number of components,</li><li>a fraction of the total squared cross-correlation, or</li><li>a relative tolerance on the number of eigenvalues greater than <code>rtol*λ₁</code> where <code>λ₁</code> is the largest eigenvalue of the correlation matrix.</li></ol><p>Given the eigendecomposition of the <span>$n × n$</span> correlation matrix, <span>$P = GΘGᵀ$</span>, with eigenvalues sorted in descending order, i.e. <span>$θ₁ ≥ θ₂ ⋯ ≥ θₙ$</span>, the first <span>$m$</span> components are selected according to one or more of the criteria listed above.</p><p>If <span>$m = n$</span>, then we have the canonical PCA-cor whitening matrix,  <span>$W = Θ^{-\frac{1}{2}}GᵀV^{-\frac{1}{2}}$</span>. Otherwise, for <span>$m &lt; n$</span>, a map from <span>$ℝⁿ ↦ ℝᵐ$</span> is formed by removing the <span>$n - m$</span> rows from <span>$W$</span>, i.e. the components with the <span>$n - m$</span> smallest eigenvalues are removed. This is equivalent to selecting the <span>$m × m$</span> matrix from the upper left of <span>$Θ$</span> and the <span>$m × n$</span> matrix from the top of <span>$Gᵀ$</span>. The inverse transform is then formed by selecting the <span>$n × m$</span> matrix from the left of <span>$G$</span> and the same matrix from <span>$Θ$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andrewjradcliffe/Whitening.jl/blob/0c16dafc2f51795aa89583673a9b0aceb17f76f0/src/GeneralizedPCAcor.jl#L1-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Whitening.GeneralizedPCAcor-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Union{Float16, Float32, Float64}" href="#Whitening.GeneralizedPCAcor-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Union{Float16, Float32, Float64}"><code>Whitening.GeneralizedPCAcor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">GeneralizedPCAcor(X::AbstractMatrix{T};
                  num_components::Union{Int, Nothing}=nothing,
                  vmin::Union{T, Nothing}=nothing,
                  rtol::Union{T, Nothing}=nothing) where {T&lt;:Base.IEEEFloat}</code></pre><p>Construct a generalized PCAcor transformer from the <code>q × n</code> matrix, each row of which is a sample of an <code>n</code>-dimensional random variable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andrewjradcliffe/Whitening.jl/blob/0c16dafc2f51795aa89583673a9b0aceb17f76f0/src/GeneralizedPCAcor.jl#L105-L113">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Whitening.GeneralizedPCAcor-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractMatrix{T}}} where T&lt;:Union{Float16, Float32, Float64}" href="#Whitening.GeneralizedPCAcor-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractMatrix{T}}} where T&lt;:Union{Float16, Float32, Float64}"><code>Whitening.GeneralizedPCAcor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">GeneralizedPCAcor(μ::AbstractVector{T}, Σ::AbstractMatrix{T};
                  num_components::Union{Int, Nothing}=nothing,
                  vmin::Union{T, Nothing}=nothing,
                  rtol::Union{T, Nothing}=nothing) where {T&lt;:Base.IEEEFloat}</code></pre><p>Construct a generalized PCAcor transformer from the mean vector, <code>μ</code> ∈ ℝⁿ, and a covariance matrix, <code>Σ</code> ∈ ℝⁿˣⁿ; <code>Σ</code> must be symmetric and positive semi-definite.</p><p>The decomposition, <span>$Σ = V^{rac{1}{2}} * P * V^{rac{1}{2}}$</span>, where <span>$V$</span> is the diagonal matrix of variances and <span>$P$</span> is a correlation matrix, must be well-formed in order to obtain a meaningful result. That is, if the diagonal of <code>Σ</code> contains 1 or more zero elements, then it is not possible to compute <span>$P = V^{-rac{1}{2}} * Σ * V^{-rac{1}{2}}$</span>.</p><p>The output dimension, <code>m</code>, of the transformer is determined from the optional arguments, where</p><ol><li>0 ≤ <code>num_components</code> ≤ n is a pre-determined size</li><li>0 ≤ <code>vmin</code> ≤ 1 is the fraction of the total squared cross-covariance,  hence, <code>m</code> is the smallest value such that <code>sum(λ[1:m]) ≥ vmin*sum(λ)</code>,  where <span>$θᵢ, i=1,…,n$</span> are the eigenvalues of <span>$P$</span> in descending order.</li><li><code>rtol</code> is the relative tolerance on the number of eigenvalues greater than <code>rtol*θ₁</code> where <code>θ₁</code> is the largest eigenvalue of <span>$P$</span>.</li></ol><p>If none of the 3 options are provided, the default is <code>rtol = n*eps(T)</code>. If 2 or more options are provided, the minimum of the resultant sizes will be chosen.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andrewjradcliffe/Whitening.jl/blob/0c16dafc2f51795aa89583673a9b0aceb17f76f0/src/GeneralizedPCAcor.jl#L58-L88">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Whitening.PCA" href="#Whitening.PCA"><code>Whitening.PCA</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PCA{T&lt;:Base.IEEEFloat} &lt;: AbstractWhiteningTransform{T}</code></pre><p>Principal component analysis (PCA) whitening transform.</p><p>Given the eigendecomposition of the covariance matrix, <span>$Σ = UΛUᵀ$</span>, we have the whitening matrix, <span>$W = Λ^{-\frac{1}{2}}Uᵀ$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andrewjradcliffe/Whitening.jl/blob/0c16dafc2f51795aa89583673a9b0aceb17f76f0/src/PCA.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Whitening.PCA-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Union{Float16, Float32, Float64}" href="#Whitening.PCA-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Union{Float16, Float32, Float64}"><code>Whitening.PCA</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PCA(X::AbstractMatrix{T}) where {T&lt;:Base.IEEEFloat}</code></pre><p>Construct a PCA transformer from the from the <code>q × n</code> matrix, each row of which is a sample of an <code>n</code>-dimensional random variable.</p><p>In order for the resultant covariance matrix to be positive definite, <code>q</code> must be ≥ <code>n</code> and none of the variances may be zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andrewjradcliffe/Whitening.jl/blob/0c16dafc2f51795aa89583673a9b0aceb17f76f0/src/PCA.jl#L39-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Whitening.PCA-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractMatrix{T}}} where T&lt;:Union{Float16, Float32, Float64}" href="#Whitening.PCA-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractMatrix{T}}} where T&lt;:Union{Float16, Float32, Float64}"><code>Whitening.PCA</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PCA(μ::AbstractVector{T}, Σ::AbstractMatrix{T}) where {T&lt;:Base.IEEEFloat}</code></pre><p>Construct a PCA transformer from the from the mean vector, <code>μ</code> ∈ ℝⁿ, and a covariance matrix, <code>Σ</code> ∈ ℝⁿˣⁿ; <code>Σ</code> must be symmetric and positive definite.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andrewjradcliffe/Whitening.jl/blob/0c16dafc2f51795aa89583673a9b0aceb17f76f0/src/PCA.jl#L29-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Whitening.PCAcor" href="#Whitening.PCAcor"><code>Whitening.PCAcor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PCAcor{T&lt;:Base.IEEEFloat} &lt;: AbstractWhiteningTransform{T}</code></pre><p>Scale-invariant principal component analysis (PCA-cor) whitening transform.</p><p>Given the eigendecomposition of the correlation matrix, <span>$P = GΘGᵀ$</span>, and the diagonal variance matrix, <span>$V$</span>, we have the whitening matrix, <span>$W = Θ^{-\frac{1}{2}}GᵀV^{-\frac{1}{2}}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andrewjradcliffe/Whitening.jl/blob/0c16dafc2f51795aa89583673a9b0aceb17f76f0/src/PCAcor.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Whitening.PCAcor-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Union{Float16, Float32, Float64}" href="#Whitening.PCAcor-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Union{Float16, Float32, Float64}"><code>Whitening.PCAcor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PCAcor(X::AbstractMatrix{T}) where {T&lt;:Base.IEEEFloat}</code></pre><p>Construct a PCAcor transformer from the from the <code>q × n</code> matrix, each row of which is a sample of an <code>n</code>-dimensional random variable.</p><p>In order for the resultant covariance matrix to be positive definite, <code>q</code> must be ≥ <code>n</code> and none of the variances may be zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andrewjradcliffe/Whitening.jl/blob/0c16dafc2f51795aa89583673a9b0aceb17f76f0/src/PCAcor.jl#L44-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Whitening.PCAcor-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractMatrix{T}}} where T&lt;:Union{Float16, Float32, Float64}" href="#Whitening.PCAcor-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractMatrix{T}}} where T&lt;:Union{Float16, Float32, Float64}"><code>Whitening.PCAcor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PCAcor(μ::AbstractVector{T}, Σ::AbstractMatrix{T}) where {T&lt;:Base.IEEEFloat}</code></pre><p>Construct a PCAcor transformer from the from the mean vector, <code>μ</code> ∈ ℝⁿ, and a covariance matrix, <code>Σ</code> ∈ ℝⁿˣⁿ; <code>Σ</code> must be symmetric and positive definite.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andrewjradcliffe/Whitening.jl/blob/0c16dafc2f51795aa89583673a9b0aceb17f76f0/src/PCAcor.jl#L34-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Whitening.ZCA" href="#Whitening.ZCA"><code>Whitening.ZCA</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ZCA{T&lt;:Base.IEEEFloat} &lt;: AbstractWhiteningTransform{T}</code></pre><p>Zero-phase component analysis (ZCA) whitening transform.</p><p>Given the covariance matrix, <span>$Σ$</span>, we have the whitening matrix, <span>$W = Σ^{-\frac{1}{2}}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andrewjradcliffe/Whitening.jl/blob/0c16dafc2f51795aa89583673a9b0aceb17f76f0/src/ZCA.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Whitening.ZCA-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Union{Float16, Float32, Float64}" href="#Whitening.ZCA-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Union{Float16, Float32, Float64}"><code>Whitening.ZCA</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ZCA(X::AbstractMatrix{T}) where {T&lt;:Base.IEEEFloat}</code></pre><p>Construct a ZCA transformer from the from the <code>q × n</code> matrix, each row of which is a sample of an <code>n</code>-dimensional random variable.</p><p>In order for the resultant covariance matrix to be positive definite, <code>q</code> must be ≥ <code>n</code> and none of the variances may be zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andrewjradcliffe/Whitening.jl/blob/0c16dafc2f51795aa89583673a9b0aceb17f76f0/src/ZCA.jl#L39-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Whitening.ZCA-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractMatrix{T}}} where T&lt;:Union{Float16, Float32, Float64}" href="#Whitening.ZCA-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractMatrix{T}}} where T&lt;:Union{Float16, Float32, Float64}"><code>Whitening.ZCA</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ZCA(μ::AbstractVector{T}, Σ::AbstractMatrix{T}) where {T&lt;:Base.IEEEFloat}</code></pre><p>Construct a ZCA transformer from the from the mean vector, <code>μ</code> ∈ ℝⁿ, and a covariance matrix, <code>Σ</code> ∈ ℝⁿˣⁿ; <code>Σ</code> must be symmetric and positive definite.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andrewjradcliffe/Whitening.jl/blob/0c16dafc2f51795aa89583673a9b0aceb17f76f0/src/ZCA.jl#L29-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Whitening.ZCAcor" href="#Whitening.ZCAcor"><code>Whitening.ZCAcor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ZCAcor{T&lt;:Base.IEEEFloat} &lt;: AbstractWhiteningTransform{T}</code></pre><p>Scale-invariant zero-phase component analysis (ZCA-cor) whitening transform.</p><p>Given the correlation matrix, <span>$P$</span>, and the diagonal variance matrix, <span>$V$</span>, we have the whitening matrix, <span>$W = P^{-\frac{1}{2}}V^{-\frac{1}{2}}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andrewjradcliffe/Whitening.jl/blob/0c16dafc2f51795aa89583673a9b0aceb17f76f0/src/ZCAcor.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Whitening.ZCAcor-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Union{Float16, Float32, Float64}" href="#Whitening.ZCAcor-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Union{Float16, Float32, Float64}"><code>Whitening.ZCAcor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ZCAcor(X::AbstractMatrix{T}) where {T&lt;:Base.IEEEFloat}</code></pre><p>Construct a ZCAcor transformer from the from the <code>q × n</code> matrix, each row of which is a sample of an <code>n</code>-dimensional random variable.</p><p>In order for the resultant covariance matrix to be positive definite, <code>q</code> must be ≥ <code>n</code> and none of the variances may be zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andrewjradcliffe/Whitening.jl/blob/0c16dafc2f51795aa89583673a9b0aceb17f76f0/src/ZCAcor.jl#L43-L51">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Whitening.ZCAcor-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractMatrix{T}}} where T&lt;:Union{Float16, Float32, Float64}" href="#Whitening.ZCAcor-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractMatrix{T}}} where T&lt;:Union{Float16, Float32, Float64}"><code>Whitening.ZCAcor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ZCAcor(μ::AbstractVector{T}, Σ::AbstractMatrix{T}) where {T&lt;:Base.IEEEFloat}</code></pre><p>Construct a ZCAcor transformer from the from the mean vector, <code>μ</code> ∈ ℝⁿ, and a covariance matrix, <code>Σ</code> ∈ ℝⁿˣⁿ; <code>Σ</code> must be symmetric and positive definite.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andrewjradcliffe/Whitening.jl/blob/0c16dafc2f51795aa89583673a9b0aceb17f76f0/src/ZCAcor.jl#L33-L39">source</a></section></article><h2 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Whitening.mahalanobis-Union{Tuple{T}, Tuple{Whitening.AbstractWhiteningTransform{T}, AbstractMatrix{T}}} where T&lt;:Union{Float16, Float32, Float64}" href="#Whitening.mahalanobis-Union{Tuple{T}, Tuple{Whitening.AbstractWhiteningTransform{T}, AbstractMatrix{T}}} where T&lt;:Union{Float16, Float32, Float64}"><code>Whitening.mahalanobis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mahalanobis(K::AbstractWhiteningTransform{T}, X::AbstractMatrix{T}) where {T&lt;:Base.IEEEFloat}</code></pre><p>Return the Mahalanobis distance, <code>√((x - μ)&#39; * Σ⁻¹ * (x - μ))</code>, computed for each row in <code>X</code>, using the transformation kernel, <code>K</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andrewjradcliffe/Whitening.jl/blob/0c16dafc2f51795aa89583673a9b0aceb17f76f0/src/abstract.jl#L187-L192">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Whitening.mahalanobis-Union{Tuple{T}, Tuple{Whitening.AbstractWhiteningTransform{T}, AbstractVector{T}}} where T&lt;:Union{Float16, Float32, Float64}" href="#Whitening.mahalanobis-Union{Tuple{T}, Tuple{Whitening.AbstractWhiteningTransform{T}, AbstractVector{T}}} where T&lt;:Union{Float16, Float32, Float64}"><code>Whitening.mahalanobis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mahalanobis(K::AbstractWhiteningTransform{T}, x::AbstractVector{T}) where {T&lt;:Base.IEEEFloat}</code></pre><p>Return the Mahalanobis distance, <code>√((x - μ)&#39; * Σ⁻¹ * (x - μ))</code>, computed using the transformation kernel, <code>K</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andrewjradcliffe/Whitening.jl/blob/0c16dafc2f51795aa89583673a9b0aceb17f76f0/src/abstract.jl#L64-L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Whitening.unwhiten-Union{Tuple{T}, Tuple{Whitening.AbstractWhiteningTransform{T}, AbstractMatrix{T}}} where T&lt;:Union{Float16, Float32, Float64}" href="#Whitening.unwhiten-Union{Tuple{T}, Tuple{Whitening.AbstractWhiteningTransform{T}, AbstractMatrix{T}}} where T&lt;:Union{Float16, Float32, Float64}"><code>Whitening.unwhiten</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unwhiten(K::AbstractWhiteningTransform{T}, Z::AbstractMatrix{T}) where {T&lt;:Base.IEEEFloat}</code></pre><p>Transform the rows of <code>Z</code> to unwhitened vectors, i.e. <code>X = Z * (W⁻¹)ᵀ .+ μᵀ</code>, using the provided kernel. That is, <code>Z</code> is an <code>m × p</code> matrix and <code>K</code> is a transformation kernel whose output dimension is <code>p</code>.</p><p>If <code>K</code> compresses <code>n ↦ p</code>, i.e. <code>z = Wx : ℝⁿ ↦ ℝᵖ</code>, then <code>X</code> is an <code>m × n</code> matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andrewjradcliffe/Whitening.jl/blob/0c16dafc2f51795aa89583673a9b0aceb17f76f0/src/abstract.jl#L159-L167">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Whitening.unwhiten-Union{Tuple{T}, Tuple{Whitening.AbstractWhiteningTransform{T}, AbstractVector{T}}} where T&lt;:Union{Float16, Float32, Float64}" href="#Whitening.unwhiten-Union{Tuple{T}, Tuple{Whitening.AbstractWhiteningTransform{T}, AbstractVector{T}}} where T&lt;:Union{Float16, Float32, Float64}"><code>Whitening.unwhiten</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unwhiten(K::AbstractWhiteningTransform{T}, z::AbstractVector{T}) where {T&lt;:Base.IEEEFloat}</code></pre><p>Transform <code>z</code> to the original coordinate system of a non-whitened vector belonging to the kernel, <code>K</code>, i.e. <code>x = μ + W⁻¹ * z</code>. This is the inverse of <code>whiten(K, x)</code>.</p><p>If <code>K</code> compresses <code>n ↦ p</code>, then <code>x ∈ ℝⁿ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andrewjradcliffe/Whitening.jl/blob/0c16dafc2f51795aa89583673a9b0aceb17f76f0/src/abstract.jl#L46-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Whitening.whiten-Union{Tuple{T}, Tuple{Whitening.AbstractWhiteningTransform{T}, AbstractMatrix{T}}} where T&lt;:Union{Float16, Float32, Float64}" href="#Whitening.whiten-Union{Tuple{T}, Tuple{Whitening.AbstractWhiteningTransform{T}, AbstractMatrix{T}}} where T&lt;:Union{Float16, Float32, Float64}"><code>Whitening.whiten</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">whiten(K::AbstractWhiteningTransform{T}, X::AbstractMatrix{T}) where {T&lt;:Base.IEEEFloat}</code></pre><p>Transform the rows of <code>X</code> to whitened vectors, i.e. <code>Z = (X .- μᵀ) * Wᵀ</code>, using the provided kernel. That is, <code>X</code> is an <code>m × n</code> matrix and <code>K</code> is a transformation kernel whose input dimension is <code>n</code>.</p><p>If <code>K</code> compresses <code>n ↦ p</code>, i.e. <code>z = Wx : ℝⁿ ↦ ℝᵖ</code>, then <code>Z</code> is an <code>m × p</code> matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andrewjradcliffe/Whitening.jl/blob/0c16dafc2f51795aa89583673a9b0aceb17f76f0/src/abstract.jl#L132-L140">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Whitening.whiten-Union{Tuple{T}, Tuple{Whitening.AbstractWhiteningTransform{T}, AbstractVector{T}}} where T&lt;:Union{Float16, Float32, Float64}" href="#Whitening.whiten-Union{Tuple{T}, Tuple{Whitening.AbstractWhiteningTransform{T}, AbstractVector{T}}} where T&lt;:Union{Float16, Float32, Float64}"><code>Whitening.whiten</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">whiten(K::AbstractWhiteningTransform{T}, x::AbstractVector{T}) where {T&lt;:Base.IEEEFloat}</code></pre><p>Transform <code>x</code> to a whitened vector, i.e. <code>z = W * (x - μ)</code>, using the transformation kernel, <code>K</code>.</p><p>If <code>K</code> compresses <code>n ↦ p</code>, then <code>z ∈ ℝᵖ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andrewjradcliffe/Whitening.jl/blob/0c16dafc2f51795aa89583673a9b0aceb17f76f0/src/abstract.jl#L30-L37">source</a></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#Whitening.mahalanobis-Union{Tuple{T}, Tuple{Whitening.AbstractWhiteningTransform{T}, AbstractVector{T}}} where T&lt;:Union{Float16, Float32, Float64}"><code>Whitening.mahalanobis</code></a></li><li><a href="#Whitening.mahalanobis-Union{Tuple{T}, Tuple{Whitening.AbstractWhiteningTransform{T}, AbstractMatrix{T}}} where T&lt;:Union{Float16, Float32, Float64}"><code>Whitening.mahalanobis</code></a></li><li><a href="#Whitening.unwhiten-Union{Tuple{T}, Tuple{Whitening.AbstractWhiteningTransform{T}, AbstractMatrix{T}}} where T&lt;:Union{Float16, Float32, Float64}"><code>Whitening.unwhiten</code></a></li><li><a href="#Whitening.unwhiten-Union{Tuple{T}, Tuple{Whitening.AbstractWhiteningTransform{T}, AbstractVector{T}}} where T&lt;:Union{Float16, Float32, Float64}"><code>Whitening.unwhiten</code></a></li><li><a href="#Whitening.whiten-Union{Tuple{T}, Tuple{Whitening.AbstractWhiteningTransform{T}, AbstractMatrix{T}}} where T&lt;:Union{Float16, Float32, Float64}"><code>Whitening.whiten</code></a></li><li><a href="#Whitening.whiten-Union{Tuple{T}, Tuple{Whitening.AbstractWhiteningTransform{T}, AbstractVector{T}}} where T&lt;:Union{Float16, Float32, Float64}"><code>Whitening.whiten</code></a></li><li><a href="#Whitening.AbstractWhiteningTransform"><code>Whitening.AbstractWhiteningTransform</code></a></li><li><a href="#Whitening.Chol"><code>Whitening.Chol</code></a></li><li><a href="#Whitening.Chol-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Union{Float16, Float32, Float64}"><code>Whitening.Chol</code></a></li><li><a href="#Whitening.Chol-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractMatrix{T}}} where T&lt;:Union{Float16, Float32, Float64}"><code>Whitening.Chol</code></a></li><li><a href="#Whitening.GeneralizedPCA-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Union{Float16, Float32, Float64}"><code>Whitening.GeneralizedPCA</code></a></li><li><a href="#Whitening.GeneralizedPCA"><code>Whitening.GeneralizedPCA</code></a></li><li><a href="#Whitening.GeneralizedPCA-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractMatrix{T}}} where T&lt;:Union{Float16, Float32, Float64}"><code>Whitening.GeneralizedPCA</code></a></li><li><a href="#Whitening.GeneralizedPCAcor-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Union{Float16, Float32, Float64}"><code>Whitening.GeneralizedPCAcor</code></a></li><li><a href="#Whitening.GeneralizedPCAcor-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractMatrix{T}}} where T&lt;:Union{Float16, Float32, Float64}"><code>Whitening.GeneralizedPCAcor</code></a></li><li><a href="#Whitening.GeneralizedPCAcor"><code>Whitening.GeneralizedPCAcor</code></a></li><li><a href="#Whitening.PCA"><code>Whitening.PCA</code></a></li><li><a href="#Whitening.PCA-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Union{Float16, Float32, Float64}"><code>Whitening.PCA</code></a></li><li><a href="#Whitening.PCA-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractMatrix{T}}} where T&lt;:Union{Float16, Float32, Float64}"><code>Whitening.PCA</code></a></li><li><a href="#Whitening.PCAcor-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Union{Float16, Float32, Float64}"><code>Whitening.PCAcor</code></a></li><li><a href="#Whitening.PCAcor"><code>Whitening.PCAcor</code></a></li><li><a href="#Whitening.PCAcor-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractMatrix{T}}} where T&lt;:Union{Float16, Float32, Float64}"><code>Whitening.PCAcor</code></a></li><li><a href="#Whitening.ZCA"><code>Whitening.ZCA</code></a></li><li><a href="#Whitening.ZCA-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractMatrix{T}}} where T&lt;:Union{Float16, Float32, Float64}"><code>Whitening.ZCA</code></a></li><li><a href="#Whitening.ZCA-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Union{Float16, Float32, Float64}"><code>Whitening.ZCA</code></a></li><li><a href="#Whitening.ZCAcor-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractMatrix{T}}} where T&lt;:Union{Float16, Float32, Float64}"><code>Whitening.ZCAcor</code></a></li><li><a href="#Whitening.ZCAcor"><code>Whitening.ZCAcor</code></a></li><li><a href="#Whitening.ZCAcor-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Union{Float16, Float32, Float64}"><code>Whitening.ZCAcor</code></a></li></ul></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.0 on <span class="colophon-date" title="Saturday 27 April 2024 01:02">Saturday 27 April 2024</span>. Using Julia version 1.11.0-beta1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
